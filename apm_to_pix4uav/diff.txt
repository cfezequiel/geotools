diff --git a/GISUtils/apm_to_pix4uav/apm2pix4uav.py b/GISUtils/apm_to_pix4uav/apm2pix4uav.py
index 39ae4f4..f2a097d 100755
--- a/GISUtils/apm_to_pix4uav/apm2pix4uav.py
+++ b/GISUtils/apm_to_pix4uav/apm2pix4uav.py
@@ -6,37 +6,40 @@ Georeferences a set of images with GPS/IMU information.
 Currently supports APM log files only.
 
 author: Carlos F. Ezequiel
-version: 2.2
+version: 2.3
 '''
 
 import logging 
 import re
 import argparse
 import csv
-from subprocess import check_output, CalledProcessError
-from cStringIO import StringIO
 from os import listdir, path, walk
 import imghdr
 from math import sqrt
 import time
 from fnmatch import fnmatch
 import bisect
-import imp
+import warnings
 
 # Third-party libraries
 try:
     import exifread
 except ImportError:
-    print 'Module not found: exifread'
+    warnings.warn('Module not found: exifread')
 
 try:
     import exiftool
 except ImportError:
-    print 'Module not found: exiftool'
+    warnings.warn('Module not found: exiftool')
 
 #======================== SETTINGS =========================
-DEBUG = logging.debug
-logging.basicConfig(level=logging.INFO)
+# Reporting
+report_filename = 'report_georef.txt'
+logging.basicConfig(
+        filename=report_filename, 
+        level=logging.INFO,
+        format='%(levelname)s:%(message)s'
+        )
 
 # Acceptable images
 image_ext = ['tiff', 'jpg', 'jpeg']
@@ -83,7 +86,7 @@ class Image:
             
         except:
             # In case EXIF data does not exist
-            print 'Could not read EXIF data -> %s' % fn
+            logging.warning('Could not read EXIF data -> %s. Using file modified time' % fn)
             t = time.localtime(path.getmtime(fn))
 
         # Convert to GPS seconds
@@ -203,6 +206,10 @@ def get_logfile(source_dir):
         if fnmatch(fn, '*.log'):
             return source_dir + '/' + fn
 
+def get_logfile_type(logfile):
+    #FIXME: for now, assume logfile is APM
+    return 'APM'
+
 def parse_apm_log_file(logfile):
     '''Read CAM entries from APM log file, which define the UAV pose at time camera was triggered.'''
 
@@ -322,14 +329,14 @@ def interpolate_nn(ts_images, ts_pose_info, analyze=False):
                 for image_ts in image_ts_list:
                     error = abs(image_ts - pose_ts)
                     errors.append(error)
-                    print('Pose(t=%d) <- Image(t=%d): error = %d' % (pose_ts, image_ts, error))
+                    logging.info('Pose(t=%d) <- Image(t=%d): error = %d' % (pose_ts, image_ts, error))
             else:
                 no_matches += 1
-                print('Pose(t=%d)' % pose_ts)
+                logging.info('Pose(t=%d)' % pose_ts)
         mse = (1.0/len(errors)) * sum([e**2 for e in errors])
-        print('Root-mean-squared-error (rmse) = %.2fms' % sqrt(mse))
-        print('Number of pose entries without match: %d' % no_matches)
-        print('Number of images with duplicate pose matchings: %d' % duplicate_images)
+        logging.info('Root-mean-squared-error (rmse) = %.2fms' % sqrt(mse))
+        logging.info('Number of pose entries without match: %d' % no_matches)
+        logging.info('Number of images with duplicate pose matchings: %d' % duplicate_images)
 
     return georef_images
 
@@ -354,7 +361,7 @@ def interpolate_linear(ts_images, ts_pose_info, analyze=False):
             x0 = tp
             x1 = seq_tp[tp_idx]
             if analyze:
-                print "image(%d) interpolated in pose_range [%d, %d]" % (x, x0, x1)
+                logging.info("image(%d) interpolated in pose_range [%d, %d]" % (x, x0, x1))
             # Multiply by 1.0 for floating-point precision
             tau = 1.0 * (x - x0) / (x1 - x0)
             pint = []
@@ -401,18 +408,12 @@ def spread_duplicates(seq):
 
 def georeference_images(images, pose_info, offset=0, algorithm='nearest_neighbor', analyze=False,
         abs_time=False):
-    #NOTE: This relies on the first image and first Pose entry
-    #to match. Otherwise, everything else will not match correctly
 
     # Get initial times
     if not abs_time:
         image_t0 = images[0].timestamp()
         pose_t0 = pose_info[0].timestamp()
 
-        # Get difference between image and pose times
-        diff = image_t0 - pose_t0
-        logging.info('Difference between initial image and pose times: %d ' % diff)
-
     # Create dictionary of image and pose timestamps based on their initial times
     # respectively
     if abs_time:
@@ -437,16 +438,22 @@ def georeference_images(images, pose_info, offset=0, algorithm='nearest_neighbor
 
     return georef_images
 
-def gen_pix4uav_file(geo_images, output_file, exclude_imu=False):
+def gen_pix4uav_file(geo_images, output_file, exclude_imu=False, header=False, ext=None):
 
     with open(output_file, 'wb') as outfp:
         writer = csv.writer(outfp, delimiter=',')
         fmt6 = '{:.6f}'
         fmt2 = '{:.2f}'
+        if header:
+            writer.writerow(['Filename', 'GPSlat', 'GPSlon', 'GPSalt', 'Yaw', 'Pitch', 'Roll'])
         for image, pose in geo_images:
             gps = pose.gps()
-            entry = [image.filename(), fmt6.format(gps.lat), fmt6.format(gps.lon),
-                    fmt2.format(gps.alt)]
+            if ext:
+                (b, e) = path.splitext(image.filename())
+                filename = b + '.' + ext
+            else:
+                filename = image.filename()
+            entry = [filename, fmt6.format(gps.lat), fmt6.format(gps.lon), fmt2.format(gps.alt)]
             imu = pose.imu()
             if not exclude_imu and imu:
                 entry += [fmt2.format(imu.yaw), fmt2.format(imu.pitch), fmt2.format(imu.roll)]
@@ -458,8 +465,9 @@ if __name__ == '__main__':
     parser = argparse.ArgumentParser(
             description=
             '''
-            Create Pix4UAV input file from images and APM logs. 
-            Performs nearest-neighbor interpolation by default
+            Create georeferencing CSV file from images and GPS logs. 
+            Performs nearest-neighbor interpolation by default.
+            Generates a report after completion.
             '''
             , epilog=
             '''
@@ -471,8 +479,8 @@ if __name__ == '__main__':
             help='Source directory for images and the APM log file (*.log)')
     parser.add_argument('--logfile', type=str, default=None,
             help='APM log file (*.log)')
-    parser.add_argument('-o', '--output', default='pix4uav.txt', 
-            help='Output Pix4UAV file [default: pix4uav.txt]')
+    parser.add_argument('-o', '--output', default='georef.csv', 
+            help='Output Pix4UAV file [default: georef.csv]')
     parser.add_argument('-d', '--output_dir', 
             help='Set the output directory for the pix4UAV file [default: source directory]')
     parser.add_argument('--exclude_imu', action='store_true', 
@@ -483,13 +491,21 @@ if __name__ == '__main__':
             help='Select interpolation algorithm (nearest_neighbor, linear)')
     parser.add_argument('--offset', type=int, default=0,
             help='Offset between camera timestamp and GPS timestamp in milliseconds (default = 0). ' + \
-                    'Positive value means camera timestamp ahead of GPS timestamp.')
+                 'Positive value means camera timestamp ahead of GPS timestamp.' +\
+                 'Only works when --absolute is enabled.')
     parser.add_argument('--absolute', action='store_true', default=False,
-            help='Use absolute timestamps for images (default uses time relative to first image time.')
+            help='Use absolute timestamps for images (default: time relative to first image time.')
+    parser.add_argument('--header', action='store_true', default=False,
+            help='Add header information to the output file.')
+    parser.add_argument('--extension', type=str, default=None,
+            help='Append a custom file extension to the image filenames in output file.')
     args = parser.parse_args()
 
     # Get image filenames
     images = get_images(args.source)
+    logging.info('Georeferencing Report')
+    logging.info('Created: %s' % time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()))
+    logging.info('Arguments: %s', str(args))
     logging.info('Found %d images in %s' % (len(images), args.source))
 
     # Get log file from source directory if not explicitly given
@@ -498,19 +514,21 @@ if __name__ == '__main__':
     else:
         logfile = args.logfile
 
-    # Read Pose data from APM log file
-    pose_info = parse_apm_log_file(logfile)
-    logging.info('Found %d camera pose entries in "%s".' % (len(pose_info), logfile))
-
-    # Check if timestamps of starting image and starting pose_info are within a threshold error
-    # FIXME: for now, assume log file type is APM
-    logfile_type = 'APM'
+    # Parse the log file
+    logfile_type = get_logfile_type(logfile)
     if logfile_type == 'APM':
+        # Read Pose data from APM log file
+        pose_info = parse_apm_log_file(logfile)
+        logging.info('Found %d camera pose entries in "%s".' % (len(pose_info), logfile))
+
         # Apply to APM version 2.76+ only
         if get_apm_version(logfile) >= 2.76:
+            # Check if timestamps of starting image and starting pose_info 
+            # are within a threshold error
             error = images[0].timestamp() - pose_info[0].timestamp() + args.offset
+            logging.info('Difference between initial image and pose time: %d ' % diff)
             if  error > image_cam_time_threshold:
-                print 'Error: Different between initial image and CAM entry time is too large: %dms' % error
+                logging.error('Difference between initial image and CAM entry time is too large')
                 exit(1)
 
     # Georeference images
@@ -529,22 +547,9 @@ if __name__ == '__main__':
         output_filename = '_linear'.join(path.splitext(output_filename))
 
     output_file = output_dir + '/' + output_filename
-    gen_pix4uav_file(georef_images, output_file, exclude_imu=args.exclude_imu)
+    gen_pix4uav_file(georef_images, output_file, exclude_imu=args.exclude_imu, 
+            header=args.header, ext=args.extension)
 
     logging.info('Done.')
 
-    exit(1)
-
-    #FIXME: temp code for DOLE
-    # Convert images filenames to tiff
-    with open(output_file, 'rt') as fp:
-        with open(output_dir + '/georef.csv', 'wt') as fp_write:
-            reader = csv.reader(fp, delimiter=',')
-            writer = csv.writer(fp_write, delimiter=',')
-            writer.writerow(['Filename', 'GPSlat', 'GPSlon', 'GPSalt', 'Yaw', 'Pitch', 'Roll'])
-            for row in reader:
-                row[0] = path.splitext(row[0])[0] + '.tiff'
-                writer.writerow(row)
-
-
 
